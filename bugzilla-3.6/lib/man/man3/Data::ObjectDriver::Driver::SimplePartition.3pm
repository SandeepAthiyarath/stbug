.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::ObjectDriver::Driver::SimplePartition 3"
.TH Data::ObjectDriver::Driver::SimplePartition 3 "2010-03-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Data::ObjectDriver::Driver::SimplePartition \- basic partitioned object driver
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package ParentObject;
\&    use base qw( Data::ObjectDriver::BaseObject );
.Ve
.PP
.Vb 6
\&    __PACKAGE__->install_properties({
\&        columns     => [ 'parent_id', 'partition_id', ... ],
\&        ...
\&        driver      => Data::ObjectDriver::Driver::DBI->new( @$GLOBAL_DB_INFO ),
\&        primary_key => 'parent_id',
\&    });
.Ve
.PP
.Vb 4
\&    __PACKAGE__->has_partitions(
\&        number     => scalar @PARTITIONS,
\&        get_driver => \e&get_driver_by_partition,
\&    );
.Ve
.PP
.Vb 2
\&    package SomeObject;
\&    use base qw( Data::ObjectDriver::BaseObject );
.Ve
.PP
.Vb 7
\&    __PACKAGE__->install_properties({
\&        ...
\&        driver               => Data::ObjectDriver::Driver::SimplePartition->new(
\&                                    using => 'ParentObject'
\&                                ),
\&        primary_key          => ['parent_id', 'object_id'],
\&    });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIData::ObjectDriver::Driver::SimplePartition\fR is a basic driver for objects
partitioned into separate databases. See
Data::ObjectDriver::Driver::Partition for more about partitioning databases.
.PP
\&\fISimplePartition\fR helps you partition objects into databases based on their
association with one record of a \fIparent\fR class. If your classes don't meet
the requirements imposed by \fISimplePartition\fR, you can still write your own
partitioning driver. See Data::ObjectDriver::Driver::Partition.
.SH "SUGGESTED PRACTICES"
.IX Header "SUGGESTED PRACTICES"
Often this is used for user partitioning, where the parent class is your user
account class; all records of other classes that are \*(L"owned\*(R" by that user are
partitioned into the same database. This allows you to scale horizontally with
the number of users, at the cost of complicating querying multiple users' data
together.
.PP
\&\fISimplePartition\fR will load the related instance of the parent class every
time it needs to find the partition for a related object. Consider using a
minimal mapping class for the parent, keeping as much data as possible in other
related classes. For example, if \f(CW\*(C`User\*(C'\fR were your parent class, you might keep
\&\fIonly\fR the user \s-1ID\s0 and other data used to find users (such as login name and
email address) in \f(CW\*(C`User\*(C'\fR, keeping further profile data in another
\&\f(CW\*(C`UserProfile\*(C'\fR class.
.PP
As all the partitioned classes related to a given parent class will share the
same \f(CW\*(C`partition_get_driver\*(C'\fR logic to turn a partition \s-1ID\s0 into a driver, you
might put the \f(CW\*(C`partition_get_driver\*(C'\fR function in the parent class, or use a
custom subclass of \fISimplePartition\fR that contains and automatically specifies
the \f(CW\*(C`partition_get_driver\*(C'\fR function.
.SH "USAGE"
.IX Header "USAGE"
.Sh "Data::ObjectDriver::Driver::SimplePartition\->new(%params)"
.IX Subsection "Data::ObjectDriver::Driver::SimplePartition->new(%params)"
Creates a new basic partitioning driver for a particular class. The required
members of \f(CW%params\fR are:
.ie n .IP "* ""using""" 4
.el .IP "* \f(CWusing\fR" 4
.IX Item "using"
The name of the parent class on which the driven class is partitioned.
.Sp
Using a class as a parent partitioned class requires these properties to be defined:
.RS 4
.ie n .IP "* ""columns""" 4
.el .IP "* \f(CWcolumns\fR" 4
.IX Item "columns"
The parent class must have a \f(CW\*(C`partition_id\*(C'\fR column containing a partition
identifier. This identifier is passed to the \f(CW\*(C`partition_get_driver\*(C'\fR function to
identify a driver to return.
.ie n .IP "* ""primary_key""" 4
.el .IP "* \f(CWprimary_key\fR" 4
.IX Item "primary_key"
The parent class's primary key must be a simple single-column key, and that
column must be the same as the referencing column in the partitioned classes.
.ie n .IP "* ""partition_get_driver""" 4
.el .IP "* \f(CWpartition_get_driver\fR" 4
.IX Item "partition_get_driver"
The \f(CW\*(C`partition_get_driver\*(C'\fR property must be a function that returns an object
driver, given a partition \s-1ID\s0 and any extra parameters given to the
\&\f(CW\*(C`SimplePartition\*(C'\fR constructor.
.Sp
This property can also be defined as \f(CW\*(C`get_driver\*(C'\fR in a call to
\&\f(CW\*(C`Class\->has_partitions()\*(C'\fR. See Data::ObjectDriver::BaseObject.
.RE
.RS 4
.RE
.PP
You can also include any further optional parameters you like. They will be
passed to the partitioned class's \f(CW\*(C`partition_get_driver\*(C'\fR function as given.
.PP
A \fISimplePartition\fR driver will require these properties to be defined for
partitioned classes:
.ie n .IP "* ""primary_key""" 4
.el .IP "* \f(CWprimary_key\fR" 4
.IX Item "primary_key"
Your primary key should be a complex primary key (arrayref) with the simple key
of the parent object for the first field.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "* ""using is required.""" 4
.el .IP "* \f(CWusing is required.\fR" 4
.IX Item "using is required."
The \f(CW\*(C`using\*(C'\fR parameter to the \fISimplePartition\fR constructor is required to
create the partitioned class's \f(CW\*(C`get_driver\*(C'\fR function. Perhaps you omitted it,
or your subclass of \fISimplePartition\fR did not properly specify it to its
parent's constructor.
.ie n .IP "* ""Bogus classname.""" 4
.el .IP "* \f(CWBogus classname.\fR" 4
.IX Item "Bogus classname."
The parent class name you specified in your \f(CW\*(C`using\*(C'\fR parameter does not appear
to be a valid class name. If you are automatically generating parent class
names, check that your method of converting strings to class names is correct.
.ie n .IP "* ""Failed to load parent class: \f(CIerror\f(CW""" 4
.el .IP "* \f(CWFailed to load parent class: \f(CIerror\f(CW\fR" 4
.IX Item "Failed to load parent class: error"
The parent class you specified in your \f(CW\*(C`using\*(C'\fR parameter could not be loaded,
for the given reason. Perhaps you didn't include its location in your library
path.
.ie n .IP "* ""Partitioning driver not defined for \f(CIpartitioned class\f(CW""" 4
.el .IP "* \f(CWPartitioning driver not defined for \f(CIpartitioned class\f(CW\fR" 4
.IX Item "Partitioning driver not defined for partitioned class"
The partitioned class named in the error is configured to use the
\&\fISimplePartition\fR driver but does not have a \f(CW\*(C`partition_get_driver\*(C'\fR set.
Check that you intended to use \fISimplePartition\fR with that class or, if you're
automatically specifying the \f(CW\*(C`partition_get_driver\*(C'\fR function, that your
technique is working correctly.
.ie n .IP "* ""Cannot extract \f(CIcolumn\f(CW from terms \f(CIsearch terms or primary key\f(CW""" 4
.el .IP "* \f(CWCannot extract \f(CIcolumn\f(CW from terms \f(CIsearch terms or primary key\f(CW\fR" 4
.IX Item "Cannot extract column from terms search terms or primary key"
The \fISimplePartition\fR driver could not determine from the given search terms
or object key what the \s-1ID\s0 of the related parent record was. Check that your
columns in the partitioned and parent classes share the same name, and that
your application includes the parent \s-1ID\s0 in all \f(CW\*(C`search()\*(C'\fR calls for the
partitioned class and instances of partitioned objects before attempting to
save them.
.Sp
Optionaly you can enable a basic support of search accross multiple
partition by passing the 'multi_partition' arg (true value) to the search
query.
.ie n .IP "* ""Member of \f(CIclass\f(CW with ID \f(CIparent \s-1ID\s0\f(CW not found""" 4
.el .IP "* \f(CWMember of \f(CIclass\f(CW with ID \f(CIparent \s-1ID\s0\f(CW not found\fR" 4
.IX Item "Member of class with ID parent ID not found"
The parent record associated with the partitioned object could not be loaded.
Perhaps your application deleted the parent record without removing its
associated partitioned objects first.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
There are no known bugs in this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::ObjectDriver::Driver::Partition
.SH "LICENSE"
.IX Header "LICENSE"
\&\fIData::ObjectDriver\fR is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
Except where otherwise noted, \fIData::ObjectDriver\fR is Copyright 2005\-2006
Six Apart, cpan@sixapart.com. All rights reserved.
