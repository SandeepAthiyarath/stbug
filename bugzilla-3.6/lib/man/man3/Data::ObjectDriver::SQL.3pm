.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::ObjectDriver::SQL 3"
.TH Data::ObjectDriver::SQL 3 "2010-03-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Data::ObjectDriver::SQL \- an SQL statement
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&    my $sql = Data::ObjectDriver::SQL->new();
\&    $sql->select([ 'id', 'name', 'bucket_id', 'note_id' ]);
\&    $sql->from([ 'foo' ]);
\&    $sql->add_where('name',      'fred');
\&    $sql->add_where('bucket_id', { op => '!=', value => 47 });
\&    $sql->add_where('note_id',   \e'IS NULL');
\&    $sql->limit(1);
.Ve
.PP
.Vb 3
\&    my $sth = $dbh->prepare($sql->as_sql);
\&    $sth->execute(@{ $sql->{bind} });
\&    my @values = $sth->selectrow_array();
.Ve
.PP
.Vb 2
\&    my $obj = SomeObject->new();
\&    $obj->set_columns(...);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIData::ObjectDriver::SQL\fR represents an \s-1SQL\s0 statement. \s-1SQL\s0 statements are used
internally to \f(CW\*(C`Data::ObjectDriver::Driver::DBI\*(C'\fR object drivers to convert
database operations (\f(CW\*(C`search()\*(C'\fR, \f(CW\*(C`update()\*(C'\fR, etc) into database operations,
but sometimes you just gotta use \s-1SQL\s0.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
\&\fIData::ObjectDriver::SQL\fR sports several data attributes that represent the
parts of the modeled \s-1SQL\s0 statement.  These attributes all have accessor and
mutator methods. Note that some attributes have more convenient methods of
modification (for example, \f(CW\*(C`add_where()\*(C'\fR for the \f(CW\*(C`where\*(C'\fR attribute).
.ie n .Sh """select"" (arrayref)"
.el .Sh "\f(CWselect\fP (arrayref)"
.IX Subsection "select (arrayref)"
The database columns to select in a \f(CW\*(C`SELECT\*(C'\fR query.
.ie n .Sh """distinct"" (boolean)"
.el .Sh "\f(CWdistinct\fP (boolean)"
.IX Subsection "distinct (boolean)"
Whether the \f(CW\*(C`SELECT\*(C'\fR query should return \s-1DISTINCT\s0 rows only.
.ie n .Sh """select_map"" (hashref)"
.el .Sh "\f(CWselect_map\fP (hashref)"
.IX Subsection "select_map (hashref)"
The map of database column names to object fields in a \f(CW\*(C`SELECT\*(C'\fR query. Use
this mapping to convert members of the \f(CW\*(C`select\*(C'\fR list to column names.
.ie n .Sh """select_map_reverse"" (hashref)"
.el .Sh "\f(CWselect_map_reverse\fP (hashref)"
.IX Subsection "select_map_reverse (hashref)"
The map of object fields to database column names in a \f(CW\*(C`SELECT\*(C'\fR query. Use
this map to reverse the \f(CW\*(C`select_map\*(C'\fR mapping where needed.
.ie n .Sh """from"" (arrayref)"
.el .Sh "\f(CWfrom\fP (arrayref)"
.IX Subsection "from (arrayref)"
The list of tables from which to query results in a \f(CW\*(C`SELECT\*(C'\fR query.
.PP
Note if you perform a \f(CW\*(C`SELECT\*(C'\fR query with multiple tables, the rows will be
selected as Cartesian products that you'll need to reduce with \f(CW\*(C`WHERE\*(C'\fR
clauses. Your query might be better served with real joins specified through
the \f(CW\*(C`joins\*(C'\fR attribute of your statement.
.ie n .Sh """joins"" (arrayref of hashrefs containing scalars and hashrefs)"
.el .Sh "\f(CWjoins\fP (arrayref of hashrefs containing scalars and hashrefs)"
.IX Subsection "joins (arrayref of hashrefs containing scalars and hashrefs)"
The list of \f(CW\*(C`JOIN\*(C'\fR clauses to use in the table list of the statement. Each clause is a hashref containing these members:
.ie n .IP "* ""table""" 4
.el .IP "* \f(CWtable\fR" 4
.IX Item "table"
The name of the table in \f(CW\*(C`from\*(C'\fR being joined.
.ie n .IP "* ""joins"" (arrayref)" 4
.el .IP "* \f(CWjoins\fR (arrayref)" 4
.IX Item "joins (arrayref)"
The list of joins to perform on the table named in \f(CW\*(C`table\*(C'\fR. Each member of
\&\f(CW\*(C`joins\*(C'\fR is a hashref containing:
.RS 4
.ie n .IP "* ""type""" 4
.el .IP "* \f(CWtype\fR" 4
.IX Item "type"
The type of join to use. That is, the \s-1SQL\s0 string to use before the word \f(CW\*(C`JOIN\*(C'\fR
in the join expression; for example, \f(CW\*(C`INNER\*(C'\fR or \f(CW\*(C`NATURAL RIGHT OUTER\*(C'\fR). This
member is optional. When not specified, the default plain \f(CW\*(C`JOIN\*(C'\fR join is
specified.
.ie n .IP "* ""table""" 4
.el .IP "* \f(CWtable\fR" 4
.IX Item "table"
The name of the table to which to join.
.ie n .IP "* ""condition""" 4
.el .IP "* \f(CWcondition\fR" 4
.IX Item "condition"
The \s-1SQL\s0 expression across which to perform the join, as a string.
.RE
.RS 4
.RE
.ie n .Sh """where"" (arrayref)"
.el .Sh "\f(CWwhere\fP (arrayref)"
.IX Subsection "where (arrayref)"
The list of \f(CW\*(C`WHERE\*(C'\fR clauses that apply to the \s-1SQL\s0 statement. Individual
members of the list are strings of \s-1SQL\s0. All members of this attribute must be
true for a record to be included as a result; that is, the list members are
\&\f(CW\*(C`AND\*(C'\fRed together to form the full \f(CW\*(C`WHERE\*(C'\fR clause.
.ie n .Sh """where_values"" (hashref of variant structures)"
.el .Sh "\f(CWwhere_values\fP (hashref of variant structures)"
.IX Subsection "where_values (hashref of variant structures)"
The set of data structures used to generate the \f(CW\*(C`WHERE\*(C'\fR clause \s-1SQL\s0 found in
the \f(CW\*(C`where\*(C'\fR attributes, keyed on the associated column names.
.ie n .Sh """bind"" (arrayref)"
.el .Sh "\f(CWbind\fP (arrayref)"
.IX Subsection "bind (arrayref)"
The list of values to bind to the query when performed. That is, the list of
values to be replaced for the \f(CW\*(C`?\*(C'\fRes in the \s-1SQL\s0.
.ie n .Sh """limit"" (scalar)"
.el .Sh "\f(CWlimit\fP (scalar)"
.IX Subsection "limit (scalar)"
The maximum number of results on which to perform the query.
.ie n .Sh """offset"" (scalar)"
.el .Sh "\f(CWoffset\fP (scalar)"
.IX Subsection "offset (scalar)"
The number of records to skip before performing the query. Combined with a
\&\f(CW\*(C`limit\*(C'\fR and application logic to increase the offset in subsequent queries,
you can paginate a set of records with a moving window containing \f(CW\*(C`limit\*(C'\fR
records.
.ie n .Sh """group"" (hashref, or an arrayref of hashrefs)"
.el .Sh "\f(CWgroup\fP (hashref, or an arrayref of hashrefs)"
.IX Subsection "group (hashref, or an arrayref of hashrefs)"
The fields on which to group the results. Grouping fields are hashrefs
containing these members:
.ie n .IP "* ""column""" 4
.el .IP "* \f(CWcolumn\fR" 4
.IX Item "column"
Name of the column on which to group.
.PP
Note you can set a single grouping field, or use an arrayref containing multiple
grouping fields.
.ie n .Sh """having"" (arrayref)"
.el .Sh "\f(CWhaving\fP (arrayref)"
.IX Subsection "having (arrayref)"
The list of clauses to specify in the \f(CW\*(C`HAVING\*(C'\fR portion of a \f(CW\*(C`GROUP ...
HAVING\*(C'\fR clause. Individual clauses are simple strings containing the
conditional expression, as in \f(CW\*(C`where\*(C'\fR.
.ie n .Sh """order"" (hashref, or an arrayref of hashrefs)"
.el .Sh "\f(CWorder\fP (hashref, or an arrayref of hashrefs)"
.IX Subsection "order (hashref, or an arrayref of hashrefs)"
Returns or sets the fields by which to order the results. Ordering fields are hashrefs containing these members:
.ie n .IP "* ""column""" 4
.el .IP "* \f(CWcolumn\fR" 4
.IX Item "column"
Name of the column by which to order.
.ie n .IP "* ""desc""" 4
.el .IP "* \f(CWdesc\fR" 4
.IX Item "desc"
The \s-1SQL\s0 keyword to use to specify the ordering. For example, use \f(CW\*(C`DESC\*(C'\fR to
specify a descending order. This member is optional.
.PP
Note you can set a single ordering field, or use an arrayref containing
multiple ordering fields.
.ie n .Sh """$sql\->comment([ $comment ])"""
.el .Sh "\f(CW$sql\->comment([ $comment ])\fP"
.IX Subsection "$sql->comment([ $comment ])"
Returns or sets a simple comment to the \s-1SQL\s0 statement
.SH "USAGE"
.IX Header "USAGE"
.ie n .Sh """Data::ObjectDriver::SQL\->new()"""
.el .Sh "\f(CWData::ObjectDriver::SQL\->new()\fP"
.IX Subsection "Data::ObjectDriver::SQL->new()"
Creates a new, empty \s-1SQL\s0 statement.
.ie n .Sh """$sql\->add_select($column [, $term ])"""
.el .Sh "\f(CW$sql\->add_select($column [, $term ])\fP"
.IX Subsection "$sql->add_select($column [, $term ])"
Adds the database column \f(CW$column\fR to the list of fields to return in a
\&\f(CW\*(C`SELECT\*(C'\fR query. The requested object member will be indicated to be \f(CW$term\fR
in the statement's \f(CW\*(C`select_map\*(C'\fR and \f(CW\*(C`select_map_reverse\*(C'\fR attributes.
.PP
\&\f(CW$term\fR is optional, and defaults to the same value as \f(CW$column\fR.
.ie n .Sh """$sql\->add_join($table, \e@joins)"""
.el .Sh "\f(CW$sql\->add_join($table, \e@joins)\fP"
.IX Subsection "$sql->add_join($table, @joins)"
Adds the join statement indicated by \f(CW$table\fR and \f(CW\*(C`\e@joins\*(C'\fR to the list of
\&\f(CW\*(C`JOIN\*(C'\fR table references for the statement. The structure for the set of joins
are as described for the \f(CW\*(C`joins\*(C'\fR attribute member above.
.ie n .Sh """$sql\->add_index_hint($table, $index)"""
.el .Sh "\f(CW$sql\->add_index_hint($table, $index)\fP"
.IX Subsection "$sql->add_index_hint($table, $index)"
Specifies a particular index to use for a particular table.
.ie n .Sh """$sql\->add_where($column, $value)"""
.el .Sh "\f(CW$sql\->add_where($column, $value)\fP"
.IX Subsection "$sql->add_where($column, $value)"
Adds a condition on the value of the database column \f(CW$column\fR to the
statement's \f(CW\*(C`WHERE\*(C'\fR clause. A record will be tested against the below
conditions according to what type of data structure \f(CW$value\fR is:
.IP "* a scalar" 4
.IX Item "a scalar"
The value of \f(CW$column\fR must equal \f(CW$value\fR.
.IP "* a reference to a scalar" 4
.IX Item "a reference to a scalar"
The value of \f(CW$column\fR must evaluate true against the \s-1SQL\s0 given in \f(CW$$value\fR.
For example, if \f(CW$$value\fR were \f(CW\*(C`IS NULL\*(C'\fR, \f(CW$column\fR must be \f(CW\*(C`NULL\*(C'\fR for a
record to pass.
.IP "* a hashref" 4
.IX Item "a hashref"
The value of \f(CW$column\fR must compare against the condition represented by
\&\f(CW$value\fR, which can contain the members:
.RS 4
.ie n .IP "* ""value""" 4
.el .IP "* \f(CWvalue\fR" 4
.IX Item "value"
The value with which to compare (required).
.ie n .IP "* ""op""" 4
.el .IP "* \f(CWop\fR" 4
.IX Item "op"
The \s-1SQL\s0 operator with which to compare \f(CW\*(C`value\*(C'\fR and the value of \f(CW$column\fR
(required).
.ie n .IP "* ""column""" 4
.el .IP "* \f(CWcolumn\fR" 4
.IX Item "column"
The column name for the comparison. If this is present, it overrides the
column name \f(CW$column\fR, allowing you to build more complex conditions
like \f(CW\*(C`((foo = 1 AND bar = 2) OR (baz = 3))\*(C'\fR.
.RE
.RS 4
.Sp
For example, if \f(CW\*(C`value\*(C'\fR were \f(CW\*(C`NULL\*(C'\fR and \f(CW\*(C`op\*(C'\fR were \f(CW\*(C`IS\*(C'\fR, a record's
\&\f(CW$column\fR column would have to be \f(CW\*(C`NULL\*(C'\fR to match.
.RE
.IP "* an arrayref of scalars" 4
.IX Item "an arrayref of scalars"
The value of \f(CW$column\fR may equal any of the members of \f(CW@$value\fR. The
generated \s-1SQL\s0 performs the comparison with as an \f(CW\*(C`IN\*(C'\fR expression.
.IP "* an arrayref of (mostly) references" 4
.IX Item "an arrayref of (mostly) references"
The value of \f(CW$column\fR must compare against \fIany\fR of the expressions
represented in \f(CW@$value\fR. Each member of the list can be any of the structures
described here as possible forms of \f(CW$value\fR.
.Sp
If the first member of the \f(CW@$value\fR array is the scalar string \f(CW\*(C`\-and\*(C'\fR,
\&\fIall\fR subsequent members of <@$value> must be met for the record to match.
Note this is not very useful unless contained as one option of a larger \f(CW\*(C`OR\*(C'\fR
alternation.
.PP
All individual conditions specified with \f(CW\*(C`add_where()\*(C'\fR must be true for a
record to be a result of the query.
.PP
Beware that you can create a circular reference that will recursively generate
an infinite \s-1SQL\s0 statement (for example, by specifying a arrayref \f(CW$value\fR that
itself contains \f(CW$value\fR). As \f(CW\*(C`add_where()\*(C'\fR evaluates your expressions before
storing the conditions in the \f(CW\*(C`where\*(C'\fR attribute as a generated \s-1SQL\s0 string,
this will occur when calling \f(CW\*(C`add_where()\*(C'\fR, not \f(CW\*(C`as_sql()\*(C'\fR. So don't do that.
.ie n .Sh """$sql\->add_complex_where(\e@list)"""
.el .Sh "\f(CW$sql\->add_complex_where(\e@list)\fP"
.IX Subsection "$sql->add_complex_where(@list)"
This method accepts an array reference of clauses that are glued together with
logical operators. With it, you can express where clauses that mix logical
operators together to produce more complex queries. For instance:
.PP
.Vb 1
\&    [ { foo => 1, bar => 2 }, -or => { baz => 3 } ]
.Ve
.PP
The values given for the columns support all the variants documented for the
\&\f(CW\*(C`add_where()\*(C'\fR method above. Logical operators used inbetween the hashref
elements can be one of: '\-or', '\-and', '\-or_not', '\-and_not'.
.ie n .Sh """$sql\->has_where($column, [$value])"""
.el .Sh "\f(CW$sql\->has_where($column, [$value])\fP"
.IX Subsection "$sql->has_where($column, [$value])"
Returns whether a where clause for the column \f(CW$column\fR was added to the
statement with the \f(CW\*(C`add_where()\*(C'\fR method.
.PP
The \f(CW$value\fR argument is currently ignored.
.ie n .Sh """$sql\->add_having($column, $value)"""
.el .Sh "\f(CW$sql\->add_having($column, $value)\fP"
.IX Subsection "$sql->add_having($column, $value)"
Adds an expression to the \f(CW\*(C`HAVING\*(C'\fR portion of the statement's \f(CW\*(C`GROUP ...
HAVING\*(C'\fR clause. The expression compares \f(CW$column\fR using \f(CW$value\fR, which can
be any of the structures described above for the \f(CW\*(C`add_where()\*(C'\fR method.
.ie n .Sh """$sql\->add_index_hint($table, \e@hints)"""
.el .Sh "\f(CW$sql\->add_index_hint($table, \e@hints)\fP"
.IX Subsection "$sql->add_index_hint($table, @hints)"
Addes the index hint into a \f(CW\*(C`SELECT\*(C'\fR query. The structure for the set of
\&\f(CW\*(C`\e@hints\*(C'\fR are arrayref of hashrefs containing these members:
.ie n .IP "* ""type"" (scalar)" 4
.el .IP "* \f(CWtype\fR (scalar)" 4
.IX Item "type (scalar)"
The name of the type. \*(L"\s-1USE\s0\*(R", \*(L"\s-1IGNORE\s0 or \*(R"\s-1FORCE\s0".
.ie n .IP "* ""list"" (arrayref)" 4
.el .IP "* \f(CWlist\fR (arrayref)" 4
.IX Item "list (arrayref)"
The list of name of indexes which to use.
.ie n .Sh """$sql\->as_sql()"""
.el .Sh "\f(CW$sql\->as_sql()\fP"
.IX Subsection "$sql->as_sql()"
Returns the \s-1SQL\s0 fully representing the \s-1SQL\s0 statement \f(CW$sql\fR.
.ie n .Sh """$sql\->as_sql_having()"""
.el .Sh "\f(CW$sql\->as_sql_having()\fP"
.IX Subsection "$sql->as_sql_having()"
Returns the \s-1SQL\s0 representing the \f(CW\*(C`HAVING\*(C'\fR portion of \f(CW$sql\fR's \f(CW\*(C`GROUP ...
HAVING\*(C'\fR clause.
.ie n .Sh """$sql\->as_sql_where()"""
.el .Sh "\f(CW$sql\->as_sql_where()\fP"
.IX Subsection "$sql->as_sql_where()"
Returns the \s-1SQL\s0 representing \f(CW$sql\fR's \f(CW\*(C`WHERE\*(C'\fR clause.
.ie n .Sh """$sql\->as_limit()"""
.el .Sh "\f(CW$sql\->as_limit()\fP"
.IX Subsection "$sql->as_limit()"
Returns the \s-1SQL\s0 for the \f(CW\*(C`LIMIT ... OFFSET\*(C'\fR clause of the statement.
.ie n .Sh """$sql\->as_aggregate($set)"""
.el .Sh "\f(CW$sql\->as_aggregate($set)\fP"
.IX Subsection "$sql->as_aggregate($set)"
Returns the \s-1SQL\s0 representing the aggregation clause of type \f(CW$set\fR for the \s-1SQL\s0
statement \f(CW$sql\fR. Reasonable values of \f(CW$set\fR are \f(CW\*(C`ORDER\*(C'\fR and \f(CW\*(C`GROUP\*(C'\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "* ""Invalid/unsafe column name \f(CIcolumn\f(CW""" 4
.el .IP "* \f(CWInvalid/unsafe column name \f(CIcolumn\f(CW\fR" 4
.IX Item "Invalid/unsafe column name column"
The column name you specified to \f(CW\*(C`add_where()\*(C'\fR contained characters that are
not allowed in database column names. Only word characters and periods are
allowed. Perhaps you didn't filter punctuation out of a generated column name
correctly.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
\&\fIData::ObjectDriver::SQL\fR does not provide the functionality for turning \s-1SQL\s0
statements into instances of object classes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SH "LICENSE"
.IX Header "LICENSE"
\&\fIData::ObjectDriver\fR is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
Except where otherwise noted, \fIData::ObjectDriver\fR is Copyright 2005\-2006
Six Apart, cpan@sixapart.com. All rights reserved.
