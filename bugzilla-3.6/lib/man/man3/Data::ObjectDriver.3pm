.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::ObjectDriver 3"
.TH Data::ObjectDriver 3 "2010-03-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Data::ObjectDriver \- Simple, transparent data interface, with caching
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&    ## Set up your database driver code.
\&    package FoodDriver;
\&    sub driver {
\&        Data::ObjectDriver::Driver::DBI->new(
\&            dsn      => 'dbi:mysql:dbname',
\&            username => 'username',
\&            password => 'password',
\&        )
\&    }
.Ve
.PP
.Vb 9
\&    ## Set up the classes for your recipe and ingredient objects.
\&    package Recipe;
\&    use base qw( Data::ObjectDriver::BaseObject );
\&    __PACKAGE__->install_properties({
\&        columns     => [ 'recipe_id', 'title' ],
\&        datasource  => 'recipe',
\&        primary_key => 'recipe_id',
\&        driver      => FoodDriver->driver,
\&    });
.Ve
.PP
.Vb 8
\&    package Ingredient;
\&    use base qw( Data::ObjectDriver::BaseObject );
\&    __PACKAGE__->install_properties({
\&        columns     => [ 'ingredient_id', 'recipe_id', 'name', 'quantity' ],
\&        datasource  => 'ingredient',
\&        primary_key => [ 'recipe_id', 'ingredient_id' ],
\&        driver      => FoodDriver->driver,
\&    });
.Ve
.PP
.Vb 4
\&    ## And now, use them!
\&    my $recipe = Recipe->new;
\&    $recipe->title('Banana Milkshake');
\&    $recipe->save;
.Ve
.PP
.Vb 5
\&    my $ingredient = Ingredient->new;
\&    $ingredient->recipe_id($recipe->id);
\&    $ingredient->name('Bananas');
\&    $ingredient->quantity(5);
\&    $ingredient->save;
.Ve
.PP
.Vb 3
\&    ## Needs more bananas!
\&    $ingredient->quantity(10);
\&    $ingredient->save;
.Ve
.PP
.Vb 4
\&    ## Shorthand constructor
\&    my $ingredient = Ingredient->new(recipe_id=> $recipe->id,
\&                                     name => 'Milk',
\&                                     quantity => 2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIData::ObjectDriver\fR is an object relational mapper, meaning that it maps
object-oriented design concepts onto a relational database.
.PP
It's inspired by, and descended from, the \fIMT::ObjectDriver\fR classes in
Six Apart's Movable Type and TypePad weblogging products. But it adds in
caching and partitioning layers, allowing you to spread data across multiple
physical databases, without your application code needing to know where the
data is stored.
.SH "METHODOLOGY"
.IX Header "METHODOLOGY"
\&\fIData::ObjectDriver\fR provides you with a framework for building
database-backed applications. It provides built-in support for object
caching and database partitioning, and uses a layered approach to allow
building very sophisticated database interfaces without a lot of code.
.PP
You can build a driver that uses any number of caching layers, plus a
partitioning layer, then a final layer that actually knows how to load
data from a backend datastore.
.PP
For example, the following code:
.PP
.Vb 8
\&    my $driver = Data::ObjectDriver::Driver::Cache::Memcached->new(
\&            cache    => Cache::Memcached->new(
\&                            servers => [ '127.0.0.1:11211' ],
\&                        ),
\&            fallback => Data::ObjectDriver::Driver::Partition->new(
\&                            get_driver => \e&get_driver,
\&                        ),
\&    );
.Ve
.PP
creates a new driver that supports both caching (using memcached) and
partitioning.
.PP
It's useful to demonstrate the flow of a sample request through this
driver framework. The following code:
.PP
.Vb 1
\&    my $ingredient = Ingredient->lookup([ $recipe->recipe_id, 1 ]);
.Ve
.PP
would take the following path through the \fIData::ObjectDriver\fR framework:
.IP "1." 4
The caching layer would look up the object with the given primary key in all
of the specified memcached servers.
.Sp
If the object was found in the cache, it would be returned immediately.
.Sp
If the object was not found in the cache, the caching layer would fall back
to the driver listed in the \fIfallback\fR setting: the partitioning layer.
.IP "2." 4
The partitioning layer does not know how to look up objects by itself\*(--all
it knows how to do is to give back a driver that \fIdoes\fR know how to look
up objects in a backend datastore.
.Sp
In our example above, imagine that we're partitioning our ingredient data
based on the recipe that the ingredient is found in. For example, all of
the ingredients for a \*(L"Banana Milkshake\*(R" would be found in one partition;
all of the ingredients for a \*(L"Chocolate Sundae\*(R" might be found in another
partition.
.Sp
So the partitioning layer needs to tell us which partition to look in to
load the ingredients for \fI$recipe\->recipe_id\fR. If we store a
\&\fIpartition_id\fR column along with each \fI$recipe\fR object, that information
can be loaded very easily, and the partitioning layer will then
instantiate a \fI\s-1DBI\s0\fR driver that knows how to load an ingredient from
that recipe.
.IP "3." 4
Using the \fI\s-1DBI\s0\fR driver that the partitioning layer created,
\&\fIData::ObjectDriver\fR can look up the ingredient with the specified primary
key. It will return that key back up the chain, giving each layer a chance
to do something with it.
.IP "4." 4
The caching layer, when it receives the object loaded in Step 3, will
store the object in memcached.
.IP "5." 4
The object will be passed back to the caller. Subsequent lookups of that
same object will come from the cache.
.SH "HOW IS IT DIFFERENT?"
.IX Header "HOW IS IT DIFFERENT?"
\&\fIData::ObjectDriver\fR differs from other similar frameworks
(e.g. Class::DBI) in a couple of ways:
.IP "* It has built-in support for caching." 4
.IX Item "It has built-in support for caching."
.PD 0
.IP "* It has built-in support for data partitioning." 4
.IX Item "It has built-in support for data partitioning."
.IP "* Drivers are attached to classes, not to the application as a whole." 4
.IX Item "Drivers are attached to classes, not to the application as a whole."
.PD
This is essential for partitioning, because your partition drivers need
to know how to load a specific class of data.
.Sp
But it can also be useful for caching, because you may find that it doesn't
make sense to cache certain classes of data that change constantly.
.IP "* The driver class != the base object class." 4
.IX Item "The driver class != the base object class."
All of the object classes you declare will descend from
\&\fIData::ObjectDriver::BaseObject\fR, and all of the drivers you instantiate
or subclass will descend from \fIData::ObjectDriver\fR itself.
.Sp
This provides a useful distinction between your data/classes, and the
drivers that describe how to \fBact\fR on that data, meaning that an
object based on \fIData::ObjectDriver::BaseObject\fR is not tied to any
particular type of driver.
.SH "USAGE"
.IX Header "USAGE"
.Sh "Class\->lookup($id)"
.IX Subsection "Class->lookup($id)"
Looks up/retrieves a single object with the primary key \fI$id\fR, and returns
the object.
.PP
\&\fI$id\fR can be either a scalar or a reference to an array, in the case of
a class with a multiple column primary key.
.Sh "Class\->lookup_multi(\e@ids)"
.IX Subsection "Class->lookup_multi(@ids)"
Looks up/retrieves multiple objects with the IDs \fI\e@ids\fR, which should be
a reference to an array of IDs. As in the case of \fIlookup\fR, an \s-1ID\s0 can
be either a scalar or a reference to an array.
.PP
Returns a reference to an array of objects \fBin the same order\fR as the IDs
you passed in. Any objects that could not successfully be loaded will be
represented in that array as an \f(CW\*(C`undef\*(C'\fR element.
.PP
So, for example, if you wanted to load 2 objects with the primary keys
\&\f(CW\*(C`[ 5, 3 ]\*(C'\fR and \f(CW\*(C`[ 4, 2 ]\*(C'\fR, you'd call \fIlookup_multi\fR like this:
.PP
.Vb 4
\&    Class->lookup_multi([
\&        [ 5, 3 ],
\&        [ 4, 2 ],
\&    ]);
.Ve
.PP
And if the first object in that list could not be loaded successfully,
you'd get back a reference to an array like this:
.PP
.Vb 4
\&    [
\&        undef,
\&        $object
\&    ]
.Ve
.PP
where \fI$object\fR is an instance of \fIClass\fR.
.Sh "Class\->search(\e%terms [, \e%options ])"
.IX Subsection "Class->search(%terms [, %options ])"
Searches for objects matching the terms \fI%terms\fR. In list context, returns
an array of matching objects; in scalar context, returns a reference to
a subroutine that acts as an iterator object, like so:
.PP
.Vb 4
\&    my $iter = Ingredient->search({ recipe_id => 5 });
\&    while (my $ingredient = $iter->()) {
\&        ...
\&    }
.Ve
.PP
\&\f(CW$iter\fR is blessed in Data::ObjectDriver::Iterator package, so the above
could also be written:
.PP
.Vb 4
\&    my $iter = Ingredient->search({ recipe_id => 5 });
\&    while (my $ingredient = $iter->next()) {
\&        ...
\&    }
.Ve
.PP
The keys in \fI%terms\fR should be column names for the database table
modeled by \fIClass\fR (and the values should be the desired values for those
columns).
.PP
\&\fI%options\fR can contain:
.IP "* sort" 4
.IX Item "sort"
The name of a column to use to sort the result set.
.Sp
Optional.
.IP "* direction" 4
.IX Item "direction"
The direction in which you want to sort the result set. Must be either
\&\f(CW\*(C`ascend\*(C'\fR or \f(CW\*(C`descend\*(C'\fR.
.Sp
Optional.
.IP "* limit" 4
.IX Item "limit"
The value for a \fI\s-1LIMIT\s0\fR clause, to limit the size of the result set.
.Sp
Optional.
.IP "* offset" 4
.IX Item "offset"
The offset to start at when limiting the result set.
.Sp
Optional.
.IP "* fetchonly" 4
.IX Item "fetchonly"
A reference to an array of column names to fetch in the \fI\s-1SELECT\s0\fR statement.
.Sp
Optional; the default is to fetch the values of all of the columns.
.IP "* for_update" 4
.IX Item "for_update"
If set to a true value, the \fI\s-1SELECT\s0\fR statement generated will include a
\&\fI\s-1FOR\s0 \s-1UPDATE\s0\fR clause.
.IP "* comment" 4
.IX Item "comment"
A sql comment to watermark the \s-1SQL\s0 query.
.IP "* window_size" 4
.IX Item "window_size"
Used when requesting an iterator for the search method and selecting
a large result set or a result set of unknown size. In such a case,
no \s-1LIMIT\s0 clause is assigned, which can load all available objects into
memory. Specifying \f(CW\*(C`window_size\*(C'\fR will load objects in manageable chunks.
This will also cause any caching driver to be bypassed for issuing
the search itself. Objects are still placed into the cache upon load.
.Sp
This attribute is ignored when the search method is invoked in an array
context, or if a \f(CW\*(C`limit\*(C'\fR attribute is also specified that is smaller than
the \f(CW\*(C`window_size\*(C'\fR.
.Sh "Class\->search(\e@terms [, \e%options ])"
.IX Subsection "Class->search(@terms [, %options ])"
This is an alternative calling signature for the search method documented
above. When providing an array of terms, it allows for constructing complex
expressions that mix 'and' and 'or' clauses. For example:
.PP
.Vb 5
\&    my $iter = Ingredient->search([ { recipe_id => 5 },
\&        -or => { calories => { value => 300, op => '<' } } ]);
\&    while (my $ingredient = $iter->()) {
\&        ...
\&    }
.Ve
.PP
Supported logic operators are: '\-and', '\-or', '\-and_not', '\-or_not'.
.Sh "Class\->add_trigger($trigger, \e&callback)"
.IX Subsection "Class->add_trigger($trigger, &callback)"
Adds a trigger to all objects of class \fIClass\fR, such that when the event
\&\fI$trigger\fR occurs to any of the objects, subroutine \f(CW&callback\fR is run. Note
that triggers will not occur for instances of \fIsubclasses\fR of \fIClass\fR, only
of \fIClass\fR itself. See \s-1TRIGGERS\s0 for the available triggers.
.Sh "Class\->call_trigger($trigger, [@callback_params])"
.IX Subsection "Class->call_trigger($trigger, [@callback_params])"
Invokes the triggers watching class \fIClass\fR. The parameters to send to the
callbacks (in addition to \fIClass\fR) are specified in \fI@callback_params\fR. See
\&\s-1TRIGGERS\s0 for the available triggers.
.Sh "$obj\->save"
.IX Subsection "$obj->save"
Saves the object \fI$obj\fR to the database.
.PP
If the object is not yet in the database, \fIsave\fR will automatically
generate a primary key and insert the record into the database table.
Otherwise, it will update the existing record.
.PP
If an error occurs, \fIsave\fR will \fIcroak\fR.
.PP
Internally, \fIsave\fR calls \fIupdate\fR for records that already exist in the
database, and \fIinsert\fR for those that don't.
.Sh "$obj\->remove"
.IX Subsection "$obj->remove"
Removes the object \fI$obj\fR from the database.
.PP
If an error occurs, \fIremove\fR will \fIcroak\fR.
.Sh "Class\->remove(\e%terms, \e%args)"
.IX Subsection "Class->remove(%terms, %args)"
Removes objects found with the \fI%terms\fR. So it's a shortcut of:
.PP
.Vb 4
\&  my @obj = Class->search(\e%terms, \e%args);
\&  for my $obj (@obj) {
\&      $obj->remove;
\&  }
.Ve
.PP
However, when you pass \f(CW\*(C`nofetch\*(C'\fR option set to \f(CW%args\fR, it won't
create objects with \f(CW\*(C`search\*(C'\fR, but issues \fI\s-1DELETE\s0\fR \s-1SQL\s0 directly to
the database.
.PP
.Vb 2
\&  ## issues "DELETE FROM tbl WHERE user_id = 2"
\&  Class->remove({ user_id => 2 }, { nofetch => 1 });
.Ve
.PP
This might be much faster and useful for tables without Primary Key,
but beware that in this case \fBTriggers won't be fired\fR because no
objects are instanciated.
.Sh "Class\->bulk_insert([col1, col2], [[d1,d2], [d1,d2]]);"
.IX Subsection "Class->bulk_insert([col1, col2], [[d1,d2], [d1,d2]]);"
Bulk inserts data into the underlying table.  The first argument
is an array reference of columns names as specified in install_properties
.Sh "$obj\->add_trigger($trigger, \e&callback)"
.IX Subsection "$obj->add_trigger($trigger, &callback)"
Adds a trigger to the object \fI$obj\fR, such that when the event \fI$trigger\fR
occurs to the object, subroutine \f(CW&callback\fR is run. See \s-1TRIGGERS\s0 for the
available triggers. Triggers are invoked in the order in which they are added.
.Sh "$obj\->call_trigger($trigger, [@callback_params])"
.IX Subsection "$obj->call_trigger($trigger, [@callback_params])"
Invokes the triggers watching all objects of \fI$obj\fR's class and the object
\&\fI$obj\fR specifically for trigger event \fI$trigger\fR. The additional parameters
besides \fI$obj\fR, if any, are passed as \fI@callback_params\fR. See \s-1TRIGGERS\s0 for
the available triggers.
.SH "TRIGGERS"
.IX Header "TRIGGERS"
\&\fIData::ObjectDriver\fR provides a trigger mechanism by which callbacks can be
called at certain points in the life cycle of an object. These can be set on a
class as a whole or individual objects (see \s-1USAGE\s0).
.PP
Triggers can be added and called for these events:
.ie n .IP "* pre_save \-> ($obj, $orig_obj)" 4
.el .IP "* pre_save \-> ($obj, \f(CW$orig_obj\fR)" 4
.IX Item "pre_save -> ($obj, $orig_obj)"
Callbacks on the \fIpre_save\fR trigger are called when the object is about to be
saved to the database. For example, use this callback to translate special code
strings into numbers for storage in an integer column in the database. Note that this hook is also called when you \f(CW\*(C`remove\*(C'\fR the object.
.Sp
Modifications to \fI$obj\fR will affect the values passed to subsequent triggers
and saved in the database, but not the original object on which the \fIsave\fR
method was invoked.
.ie n .IP "* post_save \-> ($obj, $orig_obj)" 4
.el .IP "* post_save \-> ($obj, \f(CW$orig_obj\fR)" 4
.IX Item "post_save -> ($obj, $orig_obj)"
Callbaks on the \fIpost_save\fR triggers are called after the object is
saved to the database. Use this trigger when your hook needs primary
key which is automatically assigned (like auto_increment and
sequence). Note that this hooks is \fB\s-1NOT\s0\fR called when you remove the
object.
.ie n .IP "* pre_insert/post_insert/pre_update/post_update/pre_remove/post_remove \-> ($obj, $orig_obj)" 4
.el .IP "* pre_insert/post_insert/pre_update/post_update/pre_remove/post_remove \-> ($obj, \f(CW$orig_obj\fR)" 4
.IX Item "pre_insert/post_insert/pre_update/post_update/pre_remove/post_remove -> ($obj, $orig_obj)"
Those triggers are fired before and after \f(CW$obj\fR is created, updated and
deleted.
.IP "* post_load \-> ($obj)" 4
.IX Item "post_load -> ($obj)"
Callbacks on the \fIpost_load\fR trigger are called when an object is being
created from a database query, such as with the \fIlookup\fR and \fIsearch\fR class
methods. For example, use this callback to translate the numbers your
\&\fIpre_save\fR callback caused to be saved \fIback\fR into string codes.
.Sp
Modifications to \fI$obj\fR will affect the object passed to subsequent triggers
and returned from the loading method.
.Sp
Note \fIpre_load\fR should only be used as a trigger on a class, as the object to
which the load is occuring was not previously available for triggers to be
added.
.ie n .IP "* pre_search \-> ($class, $terms\fR, \f(CW$args)" 4
.el .IP "* pre_search \-> ($class, \f(CW$terms\fR, \f(CW$args\fR)" 4
.IX Item "pre_search -> ($class, $terms, $args)"
Callbacks on the \fIpre_search\fR trigger are called when a content addressed
query for objects of class \fI$class\fR is performed with the \fIsearch\fR method.
For example, use this callback to translate the entry in \fI$terms\fR for your
code string field to its appropriate integer value.
.Sp
Modifications to \fI$terms\fR and \fI$args\fR will affect the parameters to
subsequent triggers and what objects are loaded, but not the original hash
references used in the \fIsearch\fR query.
.Sp
Note \fIpre_search\fR should only be used as a trigger on a class, as \fIsearch\fR is
never invoked on specific objects.
.RS 4
.Sp
.RS 4
The return values from your callbacks are ignored.
.Sp
Note that the invocation of callbacks is the responsibility of the object
driver. If you implement a driver that does not delegate to
\&\fIData::ObjectDriver::Driver::DBI\fR, it is \fIyour\fR responsibility to invoke the
appropriate callbacks with the \fIcall_trigger\fR method.
.RE
.RE
.RS 4
.RE
.SH "PROFILING"
.IX Header "PROFILING"
For performance tuning, you can turn on query profiling by setting
\&\fI$Data::ObjectDriver::PROFILE\fR to a true value. Or, alternatively, you can
set the \fI\s-1DOD_PROFILE\s0\fR environment variable to a true value before starting
your application.
.PP
To obtain the profile statistics, get the global
\&\fIData::ObjectDriver::Profiler\fR instance:
.PP
.Vb 1
\&    my $profiler = Data::ObjectDriver->profiler;
.Ve
.PP
Then see the documentation for \fIData::ObjectDriver::Profiler\fR to see the
methods on that class.
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
Transactions are supported by Data::ObjectDriver's default drivers. So each
Driver is capable to deal with transactional state independently. Additionally
<Data::ObjectDriver::BaseObject> class know how to turn transactions switch on
for all objects.
.PP
In the case of a global transaction all drivers used during this time are put
in a transactional state until the end of the transaction.
.Sh "Example"
.IX Subsection "Example"
.Vb 2
\&    ## start a transaction
\&    Data::ObjectDriver::BaseObject->begin_work;
.Ve
.PP
.Vb 3
\&    $recipe = Recipe->new;
\&    $recipe->title('lasagnes');
\&    $recipe->save;
.Ve
.PP
.Vb 5
\&    my $ingredient = Ingredient->new;
\&    $ingredient->recipe_id($recipe->recipe_id);
\&    $ingredient->name("more layers");
\&    $ingredient->insert;
\&    $ingredient->remove;
.Ve
.PP
.Vb 7
\&    if ($you_are_sure) {
\&        Data::ObjectDriver::BaseObject->commit;
\&    }
\&    else {
\&        ## erase all trace of the above
\&        Data::ObjectDriver::BaseObject->rollback;
\&    }
.Ve
.Sh "Driver implementation"
.IX Subsection "Driver implementation"
Drivers have to implement the following methods:
.IP "* begin_work to initialize a transaction" 4
.IX Item "begin_work to initialize a transaction"
.PD 0
.IP "* rollback" 4
.IX Item "rollback"
.IP "* commmit" 4
.IX Item "commmit"
.PD
.Sh "Nested transactions"
.IX Subsection "Nested transactions"
Are not supported and will result in warnings and the inner transactions
to be ignored. Be sure to \fBend\fR each transaction and not to let et long
running transaction open (i.e you should execute a rollback or commit for
each open begin_work).
.Sh "Transactions and \s-1DBI\s0"
.IX Subsection "Transactions and DBI"
In order to make transactions work properly you have to make sure that
the \f(CW$dbh\fR for each \s-1DBI\s0 drivers are shared among drivers using the same
database (basically dsn).
.PP
One way of doing that is to define a \fIget_dbh()\fR subref in each \s-1DBI\s0 driver
to return the same dbh if the dsn and attributes of the connection are
identical.
.PP
The other way is to use the new configuration flag on the \s-1DBI\s0 driver that
has been added specifically for this purpose: \f(CW\*(C`reuse_dbh\*(C'\fR.
.PP
.Vb 13
\&    ## example coming from the test suite
\&    __PACKAGE__->install_properties({
\&        columns => [ 'recipe_id', 'partition_id', 'title' ],
\&        datasource => 'recipes',
\&        primary_key => 'recipe_id',
\&        driver => Data::ObjectDriver::Driver::Cache::Cache->new(
\&            cache => Cache::Memory->new,
\&            fallback => Data::ObjectDriver::Driver::DBI->new(
\&                dsn      => 'dbi:SQLite:dbname=global.db',
\&                reuse_dbh => 1,  ## be sure that the corresponding dbh is shared
\&            ),
\&        ),
\&    });
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Sh "A Partitioned, Caching Driver"
.IX Subsection "A Partitioned, Caching Driver"
.Vb 3
\&    package Ingredient;
\&    use strict;
\&    use base qw( Data::ObjectDriver::BaseObject );
.Ve
.PP
.Vb 5
\&    use Data::ObjectDriver::Driver::DBI;
\&    use Data::ObjectDriver::Driver::Partition;
\&    use Data::ObjectDriver::Driver::Cache::Cache;
\&    use Cache::Memory;
\&    use Carp;
.Ve
.PP
.Vb 1
\&    our $IDs;
.Ve
.PP
.Vb 14
\&    __PACKAGE__->install_properties({
\&        columns     => [ 'ingredient_id', 'recipe_id', 'name', 'quantity', ],
\&        datasource  => 'ingredients',
\&        primary_key => [ 'recipe_id', 'ingredient_id' ],
\&        driver      =>
\&            Data::ObjectDriver::Driver::Cache::Cache->new(
\&                cache    => Cache::Memory->new( namespace => __PACKAGE__ ),
\&                fallback =>
\&                    Data::ObjectDriver::Driver::Partition->new(
\&                        get_driver   => \e&get_driver,
\&                        pk_generator => \e&generate_pk,
\&                    ),
\&            ),
\&    });
.Ve
.PP
.Vb 17
\&    sub get_driver {
\&        my($terms) = @_;
\&        my $recipe;
\&        if (ref $terms eq 'HASH') {
\&            my $recipe_id = $terms->{recipe_id}
\&                or Carp::croak("recipe_id is required");
\&            $recipe = Recipe->lookup($recipe_id);
\&        } elsif (ref $terms eq 'ARRAY') {
\&            $recipe = Recipe->lookup($terms->[0]);
\&        }
\&        Carp::croak("Unknown recipe") unless $recipe;
\&        Data::ObjectDriver::Driver::DBI->new(
\&            dsn          => 'dbi:mysql:database=cluster' . $recipe->cluster_id,
\&            username     => 'foo',
\&            pk_generator => \e&generate_pk,
\&        );
\&    }
.Ve
.PP
.Vb 5
\&    sub generate_pk {
\&        my($obj) = @_;
\&        $obj->ingredient_id(++$IDs{$obj->recipe_id});
\&        1;
\&    }
.Ve
.PP
.Vb 1
\&    1;
.Ve
.SH "SUPPORTED DATABASES"
.IX Header "SUPPORTED DATABASES"
\&\fIData::ObjectDriver\fR is very modular and it's not very diffucult to add new drivers.
.IP "* MySQL is well supported and has been heavily tested." 4
.IX Item "MySQL is well supported and has been heavily tested."
.PD 0
.IP "* PostgreSQL has been been used in production and should just work, too." 4
.IX Item "PostgreSQL has been been used in production and should just work, too."
.IP "* SQLite is supported, but \s-1YMMV\s0 depending on the version. This is the backend used for the test suite." 4
.IX Item "SQLite is supported, but YMMV depending on the version. This is the backend used for the test suite."
.IP "* Oracle support has been added in 0.06" 4
.IX Item "Oracle support has been added in 0.06"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
\&\fIData::ObjectDriver\fR is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
.SH "MAILING LIST, CODE & MORE INFORMATION"
.IX Header "MAILING LIST, CODE & MORE INFORMATION"
\&\fIData::ObjectDriver\fR developers can be reached via the following group:
<http://groups.google.com/group/data\-objectdriver>
.PP
Bugs should be reported using the \s-1CPAN\s0 \s-1RT\s0 system, patches are encouraged when
reporting bugs.
.PP
<http://code.sixapart.com/>
.PP
Alternatively you can fork our git repositories. See the full list at:
http://github.com/sixapart
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
Except where otherwise noted, \fIData::ObjectDriver\fR is Copyright 2005\-2010
Six Apart, cpan@sixapart.com. All rights reserved.
